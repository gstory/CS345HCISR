PARSER_BEGIN(HCISR)

import java.io.*;
import java.util.*;

public class HCISR {
   public static void main(String args[]) throws ParseException {
      HCISR parser = new HCISR(System.in);
      parser.File();
   }
}

PARSER_END(HCISR)

SKIP:
{ 
   " "
   | "\t"
}

TOKEN:
{

   < EOL : "\n" | "\r" | "\n\r" | "\r\n" >
   | < IDENT : ["A"-"Z"](["!"-"~"])* >
   | < END : "." >
   | < OF : "of" >
   | < A : "a" >
   | < NAMED : "named" >
   | < TYPE : "type" >
   | < ARCHTYPE : "archtype" >
   | < EXTERNALTYPE : "externaltype" >
   | < is_a_subtype_of : "is a subtype of">
   | < and_has : "and has">
   | < and_an_instance : "and an instance">
   | < understands_the_following_commands : "understands the following commands">
   | < which_initially_equals : "which initially equals">
   | < is_created_with_the_commands : "is created with the commands">
   | < this_file_uses : "this file uses">
   | < this_file_describes : "this file describes">
   | < a_Class : "a class">
   | < Functions : "functions" >
   | < a_Program : "a program" >
   | < define_a : "define a">
   | < SET : "set" >
   | < TO : "to" >
   | < IF : "if" > 
   | < otherwise : "otherwise">
   | < FOR_ALL  : "for all" >
   | < DO: "do">
   | < WHILE: "while" >
   | < COMPLAIN_ABOUT : "complain about">
   | < LABEL: "label">
   | < GOTO : "go to">
   | < NOTE : "note" >
   | < RETURNS : "returns" >
   | < RETURN : "return" >
   | < THEN : "then" >
   | < IN : "in" >
   | < AS : "as" > 
   | < and_in_the_event_of_a : "and in the event of a">
   | < the_following_functions_make_use_of: "the following functions make use of">
   | < NUMS : (["0"-"9"])+ >
   | < LP : "(" >
   | < RP : ")" > 
   | < CHARS : (["!"-"~"])+ >
}

void NL() :
{}
{
   (<EOL>)+
}

void String():
{}
{
   <CHARS>*
}

void Int():
{}
{
}

void Float():
{}
{
}

void Functioninit():
{}
{
}

void Bool():
{}
{
}

void FTIDENT() :
{}
{
   <IDENT> (<OF> (<IDENT> (<LP> TIDENT() <RP>)?)+)?
} 

void TIDENT() :
{}
{
   <IDENT> (<OF> (<IDENT>|<IDENT> <OF> )+)?
}

void FILE() :
{}
{
    <this_file_describes> <a_Class> NL() Importbody() <END> NL() Class()
   | <this_file_describes> <Functions> NL() Importbody() <END> NL() Function()
   | <this_file_describes> <a_Program> NL() Importbody() <END> NL() Function()

}

void Importbody() :
{}
{
   (Import())*
}

void Import() :
{}
{
   <this_file_uses>  (<CHARS>|<IDENT>) NL()
}

void Class() :
{}
{
    Header()  (Data())?  (Methods())?  (Constructor())?  <END> NL()
}

void Header() :
{}
{
    (<TYPE>|<ARCHTYPE>|<EXTERNALTYPE>) TIDENT() <is_a_subtype_of> TIDENT() NL()
}

void Data() :
{}
{
    Dataheader()  Databody() <END> NL()
}

void Dataheader() :
{}
{
    <and_has> NL()
}

void Databody():
{}
{
    (<A> TIDENT() <NAMED> <IDENT> (<which_initially_equals> (String()|Int()|Float()|Functioninit()|Bool()))? NL())*
}

void Methods() :
{}
{
    Methodhead()  Methodbodies() <END> NL()
}

void Methodhead():
{}
{
   <and_an_instance>  <IDENT> <understands_the_following_commands> NL()
}

void Methodbodies():
{}
{
   (Methoddec())*
}

void Methoddec():
{}
{
   Methodid()  Codebody()  <END> NL()
}

void Methodid():
{}
{
    <IDENT> (<CHARS>|(<IDENT><LP>TIDENT()<RP>))+ NL()
}

void Codebody():
{}
{
  (Returnsdec() | Codeblock())
}

void Returnsdec():
{}
{
   <RETURNS>  TIDENT()
}

void Constructor():
{}
{
   Constructorhead() Constructorbodies() NL()
}

void Constructorhead():
{}
{
   <and_an_instance><IDENT><is_created_with_the_commands> NL()
}

void Constructorbodies():
{}
{
   (Functiondec())*
}

void Functiondec():
{}
{
    Functionid()  Codebody()  <END> NL()
}

void Functionid():
{}
{
   <CHARS> (<CHARS> | (<IDENT><LP>TIDENT()<RP>))* NL()
}

void Function():
{}
{
    Fdata()  Funcs()
}

void Fdata():
{}
{
    Fdatahead()  Databody()  NL()
}

void Fdatahead():
{}
{
    <the_following_functions_make_use_of> NL() Databody() <END>  NL()
}

void Funcs():
{}
{
    (Functiondec())*
}

void Program():
{}
{
   Codeblock()
}

void Codeblock():
{}
{
   (Statement())* Returncall()  (Catchcall())*
}

void Statement():
{}
{
   (Methodcall() | Structurecall() | Functioncall())
}

void Methodcall():
{}
{
   <IDENT> (<CHARS> | <IDENT>)* NL()
}

void Structurecall():
{}
{
   Definecall() | Setcall() | Ifcall() | Forcall() | Whilecall() | Complaincall() | Labelcall() | Gotocall() | Notecall()
}

void Definecall():
{}
{
   <define_a>TIDENT()<NAMED><IDENT> (<which_initially_equals>(String()|Int()|Float()|Functioninit()|Bool()))? NL()
}

void Setcall():
{}
{
   <SET> <IDENT> <TO> (Methodcall() | Functioncall())
}

void Ifcall():
{}
{
   Conditional() Ifclause() (Elseclause())?
}

void Conditional():
{}
{
   <IF> <IDENT> <THEN> NL()
}

void Ifclause():
{}
{
   (Statement())* <END> NL()
}

void Elseclause():
{}
{
   <otherwise> NL() (Statement())* <END> NL()
}

void Forcall():
{}
{
   Fordec() (Statement())* <END> NL()
}

void Fordec():
{}
{
   <FOR_ALL> TIDENT() <NAMED> <IDENT> <IN> <IDENT> <DO> <END> NL()
}

void Whilecall():
{}
{
   Whiledec() (Statement())* <END> NL()
}

void Whiledec():
{}
{
   <WHILE> <IDENT> <DO> NL()
}

void Complaincall():
{}
{
   <COMPLAIN_ABOUT> <IDENT> NL()
}

void Labelcall():
{}
{
   <LABEL> <IDENT> NL()
}

void Gotocall():
{}
{
   <GOTO> <IDENT> NL()
}

void Notecall():
{}
{
   <NOTE> (<CHARS>|<IDENT>)* NL()
}

void Functioncall():
{}
{
   <CHARS> (<CHARS>|<IDENT>)* NL()
}

void Returncall():
{}
{
   <RETURN> <IDENT> <AS> TIDENT() NL()
}

void Catchcall():
{}
{
   Catchhead() (Statement())* <END> NL()
}

void Catchhead():
{}
{
   <and_in_the_event_of_a>TIDENT()<NAMED><IDENT> NL()
}
