PARSER_BEGIN(HCISR)

import java.io.*;
import java.util.*;

public class HCISR {
   public static void main(String args[]) throws ParseException {
      HCISR parser = new HCISR(System.in);
      parser.FILE();
   }
}

PARSER_END(HCISR)

SKIP:
{ 
   " "
   | "\t"
}

TOKEN:
{

   < EOL : "\n" | "\r" >
   | < IDENT : ["A"-"Z"](["!"-"~"])* >
   | < END : "." >
   | < OF : "of" >
   | < A : "a" >
   | < NAMED : "named" >
   | < TYPE : "type" >
   | < ARCHTYPE : "archtype" >
   | < EXTERNALTYPE : "external type" >
   | < is_a_subtype_of : "is a subtype of">
   | < and_has : "and has">
   | < and_an_instance : "and an instance">
   | < understands_the_following_commands : "understands the following commands">
   | < which_initially_equals : "which initially equals">
   | < is_created_with_the_commands : "is created with the commands">
   | < this_file_uses : "this file uses">
   | < this_file_describes : "this file describes">
   | < a_Class : "a class">
   | < Functions : "functions" >
   | < a_Program : "a program" >
   | < define_a : "define a">
   | < SET : "set" >
   | < TO : "to" >
   | < IF : "if" > 
   | < TRUE : "true" >
   | < FALSE : "false" >
   | < otherwise : "otherwise">
   | < FOR_ALL  : "for all" >
   | < DO: "do">
   | < WHILE: "while" >
   | < COMPLAIN_ABOUT : "complain about">
   | < LABEL: "label">
   | < GOTO : "go to">
   | < NOTE : "note" >
   | < RETURNS : "returns" >
   | < RETURN : "return" >
   | < THEN : "then" >
   | < IN : "in" >
   | < AS : "as" > 
   | < WITH : "with">
   | < STRINGREF : ("string")([" "-"~"]|"	")+ >
   | < INTREF: "integer" >
   | < FLOATREF: "float" >
   | < FUNCTIONREF : "function" >
   | < BOOLREF : "boolean" >
   | < make_a_new : "make a new" >
   | < and_in_the_event_of_a : "and in the event of a">
   | < the_following_functions_make_use_of: "the following functions make use of">
   | < NUMS : (["0"-"9"])+ >
   | < LP : "(" >
   | < RP : ")" > 
   | < CHARS : (["!"-"~"])+ >
}

void Any():
{}
{
   <CHARS>|<END>|<LP>|<RP>|<NUMS>|<A>|<OF>|<NAMED>|<TYPE>|<ARCHTYPE>|<EXTERNALTYPE>|<is_a_subtype_of>|<and_has>|<and_an_instance>|<understands_the_following_commands>|<which_initially_equals>|<is_created_with_the_commands>|<this_file_uses>|<this_file_describes>|<a_Class>|<Functions>|<a_Program>|<define_a>|<SET>|<TO>|<IF>|<TRUE>|<FALSE>|<otherwise>|<FOR_ALL>|<DO>|<WHILE>|<COMPLAIN_ABOUT>|<LABEL>|<GOTO>|<NOTE>|<RETURNS>|<RETURN>|<THEN>|<IN>|<AS>|<and_in_the_event_of_a>|<the_following_functions_make_use_of>|<make_a_new>|<WITH>|<STRINGREF>|<INTREF>|<FLOATREF>|<BOOLREF>|<FUNCTIONREF>

}

void Anyfirst():
{}
{
   <CHARS>|<LP>|<RP>|<NUMS>|<A>|<OF>|<NAMED>|<TYPE>|<ARCHTYPE>|<EXTERNALTYPE>|<is_a_subtype_of>|<and_has>|<and_an_instance>|<understands_the_following_commands>|<which_initially_equals>|<is_created_with_the_commands>|<this_file_uses>|<this_file_describes>|<a_Class>|<Functions>|<a_Program>|<TO>|<TRUE>|<FALSE>|<DO>|<THEN>|<IN>|<AS>|<and_in_the_event_of_a>|<the_following_functions_make_use_of>|<WITH>|<STRINGREF>|<INTREF>|<FLOATREF>|<BOOLREF>|<FUNCTIONREF>
}

void NL() :
{}
{
   (LOOKAHEAD(2)<EOL>)+
}

void String():
{}
{
   <STRINGREF>
}

void Int():
{}
{
   <INTREF><NUMS>
}

void Float():
{}
{
   <FLOATREF><NUMS><END><NUMS>
}

void Functioninit():
{}
{
   <FUNCTIONREF>(<IDENT>|<CHARS>)*
}

void Bool():
{}
{ 
   <BOOLREF>(<TRUE>|<FALSE>)
}

void FTIDENT() :
{}
{
   <IDENT> (<OF> (<IDENT> (<LP> TIDENT() <RP>)?)+)?
} 

void TIDENT() :
{}
{
   <IDENT> (<OF> (LOOKAHEAD(2) <IDENT>|<IDENT> <OF> )+)?
}

void FILE() :
{}
{
    <this_file_describes> Fileh() 
  

}

void Fileh():
{HCISRFileAST f; String[] tmp;}
{
   <a_Class> NL() tmp = Importbody() <END> NL() Class()  {for(String s : tmp) {System.out.println(s);}/*return new HCISRFileAST(String[], HCISRClassAST);*/} 
   | <Functions> NL() Importbody() <END> NL() Function() 
   | <a_Program> NL() Importbody() <END> NL() Program()
   
}

String[] Importbody() :
{String[] imports; String tmp; ArrayList<String> tobuild;}
{
   {tobuild = new ArrayList<String>();}(tmp = Import() {tobuild.add(tmp);} )* 
	{imports = new String[tobuild.size()]; 
		for(int i = 0; i<tobuild.size(); i++)
		{
		   imports[i] = tobuild.get(i);
		}
		return imports;
 	}
}

String Import() :
{Token e;}
{
   <this_file_uses>  (e = <CHARS>| e = <IDENT>) NL() {return e.image();}
}

void Class() :
{}
{
    Header()  (Data())?  (LOOKAHEAD(3) Methods())?  (LOOKAHEAD(3) Constructor())?  <END> NL()
}

void Header() :
{}
{
    (<TYPE>|<ARCHTYPE>|<EXTERNALTYPE>) FTIDENT() <is_a_subtype_of> TIDENT() NL()
}

void Data() :
{}
{
    Dataheader()  Databody() <END> NL()
}

void Dataheader() :
{}
{
    <and_has> NL()
}

void Databody():
{}
{
    (<A> TIDENT() <NAMED> <IDENT> (<which_initially_equals> (String()| LOOKAHEAD(2) Int()| LOOKAHEAD(2) Float()|Functioninit()|Bool()))? NL())* 
}

void Methods() :
{}
{
    Methodhead()  Methodbodies() <END> NL()
}

void Methodhead():
{}
{
    <and_an_instance>  <IDENT> <understands_the_following_commands> NL()
}

void Methodbodies():
{}
{
   (Methoddec())*
}

void Methoddec():
{}
{
   Methodid()  Codebody()  <END> NL()
}

void Methodid():
{}
{
    <IDENT> (Any() |(<IDENT><LP>TIDENT()<RP>))+ NL()
}

void Codebody():
{}
{
  (Returnsdec() | Codeblock())
}

void Returnsdec():
{}
{
   <RETURNS>  TIDENT() NL()
}

void Constructor():
{}
{
   Constructorhead() Constructorbodies() <END> NL()
}

void Constructorhead():
{}
{
    <and_an_instance><IDENT><is_created_with_the_commands> NL()
}

void Constructorbodies():
{}
{
   (Constructordec())*
}

void Constructordec():
{}
{
   Constructorid() Codebody() <END> NL()
}

void Constructorid():
{}
{
   <make_a_new> TIDENT() (<WITH> (Any() | (<IDENT><LP>TIDENT()<RP>))*)? NL()
}

void Functiondec():
{}
{
    Functionid()  Codebody()  <END> NL()
}

void Functionid():
{}
{
   Anyfirst() (Any() | (<IDENT><LP>TIDENT()<RP>))* NL()
}

void Function():
{}
{
    Fdata()  Funcs()
}

void Fdata():
{}
{
    Fdatahead()  Databody()  <END> NL()
}

void Fdatahead():
{}
{
    <the_following_functions_make_use_of>  NL()
}

void Funcs():
{}
{
    (Functiondec())*
}

void Program():
{}
{
   Codeblock()
}

void Codeblock():
{}
{
   (Statement())* Returncall()  (Catchcall())*
}

void Statement():
{}
{
   (Methodcall() | Structurecall() | Functioncall() | Constructorcall())
}

void Methodcall():
{}
{
   <IDENT> (Any() | <IDENT>)* NL()
}

void Constructorcall():
{}
{
   <make_a_new> TIDENT() (<WITH> (Any() | <IDENT>)*)? NL()
}

void Structurecall():
{}
{
   Definecall() | Setcall() | Ifcall() | Forcall() | Whilecall() | Complaincall() | Labelcall() | Gotocall() | Notecall()
}

void Definecall():
{}
{
   <define_a>TIDENT()<NAMED><IDENT> (<which_initially_equals>(String()|Int()|Float()|Functioninit()|Bool()))? NL()
}

void Setcall():
{}
{
   <SET> <IDENT> <TO> (Methodcall() | Functioncall())
}

void Ifcall():
{}
{
   Conditional() Ifclause() (Elseclause())?
}

void Conditional():
{}
{
   <IF> <IDENT> <THEN> NL()
}

void Ifclause():
{}
{
   (Statement())* <END> NL()
}

void Elseclause():
{}
{
   <otherwise> NL() (Statement())* <END> NL()
}

void Forcall():
{}
{
   Fordec() (Statement())* <END> NL()
}

void Fordec():
{}
{
   <FOR_ALL> TIDENT() <NAMED> <IDENT> <IN> <IDENT> <DO> <END> NL()
}

void Whilecall():
{}
{
   Whiledec() (Statement())* <END> NL()
}

void Whiledec():
{}
{
   <WHILE> <IDENT> <DO> NL()
}

void Complaincall():
{}
{
   <COMPLAIN_ABOUT> <IDENT> NL()
}

void Labelcall():
{}
{
   <LABEL> <IDENT> NL()
}

void Gotocall():
{}
{
   <GOTO> <IDENT> NL()
}

void Notecall():
{}
{
   <NOTE> (<CHARS>|<IDENT>)* NL()
}

void Functioncall():
{}
{
   Anyfirst() (Any()|<IDENT>)* NL()
}

void Returncall():
{}
{
   <RETURN> <IDENT> <AS> TIDENT() NL()
}

void Catchcall():
{}
{
   Catchhead() (Statement())* <END> NL()
}

void Catchhead():
{}
{
   <and_in_the_event_of_a>TIDENT()<NAMED><IDENT> NL()
}


