PARSER_BEGIN(HCISR)

import java.io.*;
import java.util.*;

public class HCISR {

}
PASER_END(HCISR) 

SKIP:
{ 
   " "
   | "\t"
}

TOKEN:
{

   < EOL : "\n" | "\r" | "\n\r" | "\r\n" >
   < IDENT : ["A"-"Z"](["!"-"~"])* >
   < END : "." >
   < OF : "of" >
   < A : "a" >
   < NAMED : "named" >
   < TYPE : "type" >
   < ARCHTYPE : "archtype" >
   < EXTERNALTYPE : "externaltype" >
   < is_a_sub_type_of : "is a subtype of">
   < and_has : "and has">
   < and_an_instance : "and an instance">
   < understands_the_following_commands : "understands the following commands">
   < which_initially_equals : "which initially equals">
   < is_created_with_the_commands : "is created with the commands">
   < this_file_uses : "this file uses">
   < this_file_describes : "this file describes">
   < a_Class : "a class">
   < Functions : "functions" >
   < a_Program : "a program" >
   < define_a : "define a ">
   < SET : "set" >
   < TO : "to" >
   < IF : "if" > 
   < otherwise : "otherwise">
   < FOR_ALL  : "for all" >
   < DO: "do">
   < WHILE: "while" >
   < COMPLAIN_ABOUT : "complain about">
   < LABEL: "label">
   < GOTO : "go to">
   < NOTE : "note" >
   < RETURN : "return" >
   < and_in_the_event_of : "and in the event of">
   < NUMS : ["0"-"9"]+>
   < LP : "(" >
   < RP : ")" > 
   < CHARS : (["!"-"~"])+>
}

void NL() :
{}
{
   (<EOL>)+
}

void FTIDENT() :
{}
{
   <IDENT> (<OF> (<IDENT> (<LP> TIDENT() <RP>)?)+)?
} 

void TIDENT() :
{}
{
   <IDENT> (<OF> (<IDENT>|<IDENT> <OF> )+)?
}

void FILE() :
{}
{
    <this_file_describes> <a_Class> NL() Importbody() <END> NL() Class()
   | <this_file_describes> <Functions> NL() Importbody() <END> NL() Functions()
   | <this_file_describes> <a_Program> NL() Importbody() <END> NL() Functions()

}

void Importbody() :
{}
{
   (Import())*
}

void Import() :
{}
{
   <this_file_uses>  (<CHARS>|<IDENT>) NL
}

void Class() :
{}
{
    Header()  (Data())?  (Methods())?  (Constructor())?  <END> NL()
}

void Header() :
{}
{
    (<TYPE>|<ARCHTYPE>|<EXTERNALTYPE>) <TIDENT> <is_a_subtype_of> <TIDENT> NL()
}

void Data() :
{}
{
    Dataheader()  Databody() <END> NL()
}

void Dataheader() :
{}
{
    <and_has> NL()
}

void Databody():
{}
{
    (<A> <TIDENT> <NAMED> <IDENT> (<which_initially_equals> (<STRING>|<INT>|<FLOAT>|Function()|<BOOL>))? NL())*
}

void Methods() :
{}
{
    Methodhead()  Methodbodies() <END> NL()
}

void Methodhead():
{}
{
   <and_an_instance>  <IDENT> <understands_the_following_commands> NL()
}

void Methodbodies():
{}
{
   (Methoddec())*
}

void Methoddec():
{}
{
   Methodid()  Codebody()  <END> NL()
}

void Methodid():
{}
{
    <IDENT> (<CHARS>||(<IDENT><LP><TIDENT><RP>))+ NL()
}

void Codebody():
{}
{
  (Returnsdec() | Codeblock())
}

void Returnsdec():
{}
{
   <returns>  <TIDENT>
}

void Constructor():
{}
{
   Constructorhead() Constructorbodies() NL()
}

void Constructorhead():
{}
{
   <and_an_instance><IDENT><is_created_with_the_commands> NL()
}

void Constructorbodies():
{}
{
   (Functiondec())*
}

void Functiondec():
{}
{
    Functionid()  Codebody()  <END> NL()
}

void Functionid():
{}
{
   <CHARS> (<CHARS> | <S> | (<S><IDENT><S><LP><S><TIDENT><S><RP><S>))* NL()
}

void Functions():
{}
{
   <S> Fdata() <S> Funcs()
}

void Fdata():
{}
{
    Fdatahead() <S> Databody() <END> NL()
}

void Funcs():
{}
{
    (Functiondec())*
}

void Program():
{}
{
   Codeblock()
}

void Codeblock():
{}
{
   (Statement())* Returncall()  (Catchcall())*
