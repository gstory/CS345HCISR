PARSER_BEGIN(HCISR)

import java.io.*;
import java.util.*;

public class HCISR {
   public static void main(String args[]) throws ParseException {
      HCISR parser = new HCISR(System.in);
      parser.FILE();
   }
}

PARSER_END(HCISR)

SKIP:
{ 
   " "
   | "\t"
}

TOKEN:
{

   < EOL : "\n" | "\r" >
   | < END : "." >
   | < OF : "of" >
   | < A : "a" >
   | < NAMED : "named" >
   | < TYPE : "type" >
   | < ARCHTYPE : "archtype" >
   | < EXTERNALTYPE : "external type" >
   | < is_a_subtype_of : "is a subtype of">
   | < and_has : "and has">
   | < and_an_instance : "and an instance">
   | < understands_the_following_commands : "understands the following commands">
   | < which_initially_equals : "which initially equals">
   | < is_created_with_the_commands : "is created with the commands">
   | < this_file_uses : "this file uses">
   | < this_file_describes : "this file describes">
   | < a_Class : "a class">
   | < Functions : "functions" >
   | < a_Program : "a program" >
   | < define_a : "define a">
   | < SET : "set" >
   | < TO : "to" >
   | < IF : "if" > 
   | < TRUE : "true" >
   | < FALSE : "false" >
   | < otherwise : "otherwise">
   | < FOR_ALL  : "for all" >
   | < DO: "do">
   | < WHILE: "while" >
   | < COMPLAIN_ABOUT : "complain about">
   | < LABEL: "label">
   | < GOTO : "go to">
   | < NOTE : "note" >
   | < RETURNS : "returns" >
   | < RETURN : "return" >
   | < THEN : "then" >
   | < IN : "in" >
   | < AS : "as" > 
   | < WITH : "with">
   | < STRINGREF : ("String:")([" "-"~"]|"	")+ >
   | < INTREF: "Integer:" >
   | < FLOATREF: "Float:" >
   | < FUNCTIONREF : "Function:" >
   | < BOOLREF : "Boolean:" >
   | < make_a_new : "make a new" >
   | < and_in_the_event_of_a : "and in the event of a">
   | < the_following_functions_make_use_of: "the following functions make use of">
   | < IDENT : ["A"-"Z"](["!"-"~"])* >
   | < NUMS : (["0"-"9"])+ >
   | < LP : "(" >
   | < RP : ")" > 
   | < CHARS : (["!"-"~"])+ >
}

void Any():
{}
{
   <CHARS>|<END>|<LP>|<RP>|<NUMS>|<A>|<OF>|<NAMED>|<TYPE>|<ARCHTYPE>|<EXTERNALTYPE>|<is_a_subtype_of>|<and_has>|<and_an_instance>|<understands_the_following_commands>|<which_initially_equals>|<is_created_with_the_commands>|<this_file_uses>|<this_file_describes>|<a_Class>|<Functions>|<a_Program>|<define_a>|<SET>|<TO>|<IF>|<TRUE>|<FALSE>|<otherwise>|<FOR_ALL>|<DO>|<WHILE>|<COMPLAIN_ABOUT>|<LABEL>|<GOTO>|<NOTE>|<RETURNS>|<RETURN>|<THEN>|<IN>|<AS>|<and_in_the_event_of_a>|<the_following_functions_make_use_of>|<make_a_new>|<WITH>|<STRINGREF>|<INTREF>|<FLOATREF>|<BOOLREF>|<FUNCTIONREF>

}

void Anyfirst():
{}
{
   <CHARS>|<LP>|<RP>|<NUMS>|<A>|<OF>|<NAMED>|<TYPE>|<ARCHTYPE>|<EXTERNALTYPE>|<is_a_subtype_of>|<and_has>|<and_an_instance>|<understands_the_following_commands>|<which_initially_equals>|<is_created_with_the_commands>|<this_file_uses>|<this_file_describes>|<a_Class>|<Functions>|<a_Program>|<TO>|<TRUE>|<FALSE>|<DO>|<THEN>|<IN>|<AS>|<and_in_the_event_of_a>|<the_following_functions_make_use_of>|<WITH>|<STRINGREF>|<INTREF>|<FLOATREF>|<BOOLREF>|<FUNCTIONREF>
}

void NL() :
{}
{
   (LOOKAHEAD(2)<EOL>)+
}

void String():
{}
{
   <STRINGREF>
}

void Int():
{}
{
   <INTREF><NUMS>
}

void Float():
{}
{
   <FLOATREF><NUMS><END><NUMS>
}

void Functioninit():
{}
{
   <FUNCTIONREF>(<IDENT>|<CHARS>)*
}

void Bool():
{}
{ 
   <BOOLREF>(<TRUE>|<FALSE>)
}

Object[] FTIDENT() :
{String[] fullTypeName; String[] tmpres; String[][] parameterLimiters; ArrayList<String> tmpname; ArrayList<String[]> tmprestrictions; boolean seenres; Token e; Object[] returnarray;}
{
   {tmpname = new ArrayList<String>(); tmprestrictions = new ArrayList<String[]>();}   


   e = <IDENT> {tmpname.add(e.image()); tmprestrictions.add(null); }
	( e = <OF> {tmpname.add(e.image()); tmprestrictions.add(null);} 
		( e = <IDENT> {tmpname.add(e.image()); seenres = false;} 
			(<LP> tmpres = TIDENT() {seenres = true;} <RP>)? 
				{tmprestrictions.add(seenres?tmpres:null);})+)?
   {fullTypeName = new String[tmpname.size()]; 
	for(int i = 0; i < fullTypeName.length; i++){
	   fullTypeName[i] = tmpname.get(i);	
	}
	parameterLimiters = new String[tmprestrictions.size()][];
	for(int i = 0; i < parameterLimiters.length; i++){
	   parameterLimiters[i] = tmprestrictions.get(i);
	} 
	returnarray = new Object[2];
	returnarray[0] = fullTypeName;
	returnarray[1] = parameterLimiters;
	return returnarray;
   }
} 

String[] TIDENT() :
{String[] fullTypeName; Token e; ArrayList<String> tmpname;}
{
   e = <IDENT> {tmpname.add(e.image());} (e = <OF> {tmpname.add(e.image());} (LOOKAHEAD(2) e = <IDENT>{tmpname.add(e.image());}|e = <IDENT>{tmpname.add(e.image());} e = <OF>{tmpname.add(e.image());} )+)?
	{fullTypeName = new String[tmpname.size()];
		for(int i = 0; i < fullTypeName.length; i++){
			fullTypeName[i] = tmpname.get(i); }
	return fullTypeName;}
}

void FILE() :
{}
{
    <this_file_describes> Fileh() 
  

}

void Fileh():
{HCISRFileAST f; String[] tmp;}
{
   <a_Class> NL() tmp = Importbody() <END> NL() Class()  {for(String s : tmp) {System.out.println(s);}/*return new HCISRFileAST(String[], HCISRClassAST);*/} 
   | <Functions> NL() tmp = Importbody() <END> NL() Function() {for(String s : tmp) {System.out.println(s);}/*return new HCISRFileAST(String[], HCISRFunctionFileAST);*/}
   | <a_Program> NL() tmp = Importbody() <END> NL() Program() {for(String s : tmp) {System.out.println(s);}/*return new HCISRFileAST(String[], HCISRStatementAST[]);*/}
   
}

String[] Importbody() :
{String[] imports; String tmp; ArrayList<String> tobuild;}
{
   {tobuild = new ArrayList<String>();}(tmp = Import() {tobuild.add(tmp);} )* 
	{imports = new String[tobuild.size()]; 
		for(int i = 0; i<tobuild.size(); i++)
		{
		   imports[i] = tobuild.get(i);
		}
		return imports;
 	}
}

String Import() :
{Token e;}
{
   <this_file_uses>  (e = <CHARS>| e = <IDENT>) NL() {return e.image();}
}

void Class() :
{int classClassification; String[] fullTypeName; String[][] parameterLimiters; String[] fullSuperTypeName; HCISRVariableAST[] instanceVariableList;HCISRMethodAST[] instanceMethodList;HCISRConstructorAST[] fullConstructorList;String methodSelfReference;String constructorSelfReference; /*starting tmps*/ Object[] headerReturn; Object[] methodReturn; Object[] constructorReturn; }
{
	{instanceVariableList = null; instanceMethodList = null; fullConstructorList = null;}
    headerReturn = Header()  (instanceVariableList = Data())?  (LOOKAHEAD(3) methodReturn = Methods())?  (LOOKAHEAD(3) constructorReturn = Constructor())?  <END> NL()
	{
		
		if (instanceVariableList == null) { instanceVariableList = new HCISRVariableAST[0];}
		methodSelfReference = methodReturn[0];
		instanceMethodList = methodReturn[1];
		if (instanceMethodList == null) { instanceMethodList = new HCISRMethodAST[0];}
		constructorSelfReference = constructorReturn[0];
		fullConstructorList = constructorReturn[1];
		if (fullConstructorList == null) { fullConstructorList = new HCISRConstructorAST[0];}
	}
}

Object[] Header() :
{String[] fullTypeName; String[] fullSuperTypeName; Object[] filetypeident; String[][] parameterLimiters; int classtype; Object[] returnarray;}
{
    (<TYPE>{classtype = 0}|<ARCHTYPE>{classtype = 1}|<EXTERNALTYPE>{classtype = 2}) filetypeident = FTIDENT() <is_a_subtype_of> fullSuperTypeName = TIDENT() NL()
	{
		fullTypeName = filetypeident[0]; 
		parameterLimiters = filetypeident[1];
		returnarray[0] = classClassification;
		returnarray[1] = fullTypeName;
		returnarray[2] = parameterLimiters;
		returnarray[3] = fullSuperTypeName;
		return returnarray;
	}
}

HCISRVariableAST[] Data() :
{String[] typeDeclaration; String variableName; int initializedType; String initializedValue;}
{
    Dataheader()  Databody() <END> NL()
}

void Dataheader() :
{}
{
    <and_has> NL()
}

HCISRVariableAST[] Databody():
{}
{
    (<A> TIDENT() <NAMED> <IDENT> (<which_initially_equals> (String()| LOOKAHEAD(2) Int()| LOOKAHEAD(2) Float()|Functioninit()|Bool()))? NL())* 
}

Object[] Methods() :
{Object[] returnarray; String methodselfreference;}
{
    methodselfreference = Methodhead()  Methodbodies() <END> NL()
	{
		returnarray[0] = methodselfreference;
		//need something here for Methodbodies
	}
}

String Methodhead():
{String methodselfreference; Token e;}
{
    <and_an_instance>  e = <IDENT> <understands_the_following_commands> NL()
	{
		methodselfreference = e.image();
		return methodselfreference;
	}
}

void Methodbodies():
{}
{
   (Methoddec())*
}

void Methoddec():
{}
{
   Methodid()  Codebody()  <END> NL()
}

void Methodid():
{}
{
    <IDENT> (Any() |(<IDENT><LP>TIDENT()<RP>))+ NL()
}

void Codebody():
{}
{
  (Returnsdec() | Codeblock())
}

void Returnsdec():
{}
{
   <RETURNS>  TIDENT() NL()
}

Object[] Constructor():
{Object[] returnarray; String constructorselfreference;}
{
   constructorselfreference = Constructorhead() Constructorbodies() <END> NL()
	{
		returnarray[0] = constructorselfreference;
		//need something here for constructorbodies
	}
}

String Constructorhead():
{String constructorselfreference; Token e;}
{
    <and_an_instance> e = <IDENT><is_created_with_the_commands> NL()
	{
		constructorselfreference = e.image();
		return constructorselfreference;	
	}
}

void Constructorbodies():
{}
{
   (Constructordec())*
}

void Constructordec():
{}
{
   Constructorid() Codebody() <END> NL()
}

void Constructorid():
{}
{
   <make_a_new> TIDENT() (<WITH> (Any() | (<IDENT><LP>TIDENT()<RP>))*)? NL()
}

void Functiondec():
{}
{
    Functionid()  Codebody()  <END> NL()
}

void Functionid():
{}
{
   Anyfirst() (Any() | (<IDENT><LP>TIDENT()<RP>))* NL()
}

void Function():
{}
{
    Fdata()  Funcs()
}

void Fdata():
{}
{
    Fdatahead()  Databody()  <END> NL()
}

void Fdatahead():
{}
{
    <the_following_functions_make_use_of>  NL()
}

void Funcs():
{}
{
    (Functiondec())*
}

void Program():
{}
{
   Codeblock()
}

void Codeblock():
{}
{
   (Statement())* Returncall()  (Catchcall())*
}

void Statement():
{}
{
   (Methodcall() | Structurecall() | Functioncall() | Constructorcall())
}

void Methodcall():
{}
{
   <IDENT> (Any() | <IDENT>)* NL()
}

void Constructorcall():
{}
{
   <make_a_new> TIDENT() (<WITH> (Any() | <IDENT>)*)? NL()
}

void Structurecall():
{}
{
   Definecall() | Setcall() | Ifcall() | Forcall() | Whilecall() | Complaincall() | Labelcall() | Gotocall() | Notecall()
}

void Definecall():
{}
{
   <define_a>TIDENT()<NAMED><IDENT> (<which_initially_equals>(String()|Int()|Float()|Functioninit()|Bool()))? NL()
}

void Setcall():
{}
{
   <SET> <IDENT> <TO> (Methodcall() | Functioncall())
}

void Ifcall():
{}
{
   Conditional() Ifclause() (Elseclause())?
}

void Conditional():
{}
{
   <IF> <IDENT> <THEN> NL()
}

void Ifclause():
{}
{
   (Statement())* <END> NL()
}

void Elseclause():
{}
{
   <otherwise> NL() (Statement())* <END> NL()
}

void Forcall():
{}
{
   Fordec() (Statement())* <END> NL()
}

void Fordec():
{}
{
   <FOR_ALL> TIDENT() <NAMED> <IDENT> <IN> <IDENT> <DO> <END> NL()
}

void Whilecall():
{}
{
   Whiledec() (Statement())* <END> NL()
}

void Whiledec():
{}
{
   <WHILE> <IDENT> <DO> NL()
}

void Complaincall():
{}
{
   <COMPLAIN_ABOUT> <IDENT> NL()
}

void Labelcall():
{}
{
   <LABEL> <IDENT> NL()
}

void Gotocall():
{}
{
   <GOTO> <IDENT> NL()
}

void Notecall():
{}
{
   <NOTE> (<CHARS>|<IDENT>)* NL()
}

void Functioncall():
{}
{
   Anyfirst() (Any()|<IDENT>)* NL()
}

void Returncall():
{}
{
   <RETURN> <IDENT> <AS> TIDENT() NL()
}

void Catchcall():
{}
{
   Catchhead() (Statement())* <END> NL()
}

void Catchhead():
{}
{
   <and_in_the_event_of_a>TIDENT()<NAMED><IDENT> NL()
}


