/* Generated By:JavaCC: Do not edit this line. HCISR.java */
package hcisr;
import java.io.*;
import java.util.*;
import hcisr.ast.*;

public class HCISR implements HCISRConstants {
        public static String constructorvar;

   public static HCISRFileAST parseFile(InputStream ins) throws ParseException {
      HCISR parser = new HCISR(ins);
      return parser.FILE();
   }

  final public String Any() throws ParseException {
 Token e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARS:
      e = jj_consume_token(CHARS);
      break;
    case END:
      e = jj_consume_token(END);
      break;
    case LP:
      e = jj_consume_token(LP);
      break;
    case RP:
      e = jj_consume_token(RP);
      break;
    case NUMS:
      e = jj_consume_token(NUMS);
      break;
    case A:
      e = jj_consume_token(A);
      break;
    case OF:
      e = jj_consume_token(OF);
      break;
    case NAMED:
      e = jj_consume_token(NAMED);
      break;
    case TYPE:
      e = jj_consume_token(TYPE);
      break;
    case ARCHTYPE:
      e = jj_consume_token(ARCHTYPE);
      break;
    case EXTERNALTYPE:
      e = jj_consume_token(EXTERNALTYPE);
      break;
    case is_a_subtype_of:
      e = jj_consume_token(is_a_subtype_of);
      break;
    case and_has:
      e = jj_consume_token(and_has);
      break;
    case and_an_instance:
      e = jj_consume_token(and_an_instance);
      break;
    case understands_the_following_commands:
      e = jj_consume_token(understands_the_following_commands);
      break;
    case which_initially_equals:
      e = jj_consume_token(which_initially_equals);
      break;
    case is_created_with_the_commands:
      e = jj_consume_token(is_created_with_the_commands);
      break;
    case this_file_uses:
      e = jj_consume_token(this_file_uses);
      break;
    case this_file_describes:
      e = jj_consume_token(this_file_describes);
      break;
    case a_Class:
      e = jj_consume_token(a_Class);
      break;
    case Functions:
      e = jj_consume_token(Functions);
      break;
    case a_Program:
      e = jj_consume_token(a_Program);
      break;
    case define_a:
      e = jj_consume_token(define_a);
      break;
    case SET:
      e = jj_consume_token(SET);
      break;
    case TO:
      e = jj_consume_token(TO);
      break;
    case IF:
      e = jj_consume_token(IF);
      break;
    case TRUE:
      e = jj_consume_token(TRUE);
      break;
    case FALSE:
      e = jj_consume_token(FALSE);
      break;
    case otherwise:
      e = jj_consume_token(otherwise);
      break;
    case FOR_ALL:
      e = jj_consume_token(FOR_ALL);
      break;
    case DO:
      e = jj_consume_token(DO);
      break;
    case WHILE:
      e = jj_consume_token(WHILE);
      break;
    case COMPLAIN_ABOUT:
      e = jj_consume_token(COMPLAIN_ABOUT);
      break;
    case LABEL:
      e = jj_consume_token(LABEL);
      break;
    case GOTO:
      e = jj_consume_token(GOTO);
      break;
    case NOTE:
      e = jj_consume_token(NOTE);
      break;
    case RETURNS:
      e = jj_consume_token(RETURNS);
      break;
    case RETURN:
      e = jj_consume_token(RETURN);
      break;
    case THEN:
      e = jj_consume_token(THEN);
      break;
    case IN:
      e = jj_consume_token(IN);
      break;
    case AS:
      e = jj_consume_token(AS);
      break;
    case and_in_the_event_of_a:
      e = jj_consume_token(and_in_the_event_of_a);
      break;
    case the_following_functions_make_use_of:
      e = jj_consume_token(the_following_functions_make_use_of);
      break;
    case make_a_new:
      e = jj_consume_token(make_a_new);
      break;
    case WITH:
      e = jj_consume_token(WITH);
      break;
    case STRINGREF:
      e = jj_consume_token(STRINGREF);
      break;
    case INTREF:
      e = jj_consume_token(INTREF);
      break;
    case FLOATREF:
      e = jj_consume_token(FLOATREF);
      break;
    case BOOLREF:
      e = jj_consume_token(BOOLREF);
      break;
    case FUNCTIONREF:
      e = jj_consume_token(FUNCTIONREF);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {if (true) return e.image;}
    throw new Error("Missing return statement in function");
  }

  final public String Anyfirst() throws ParseException {
 Token e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARS:
      e = jj_consume_token(CHARS);
      break;
    case LP:
      e = jj_consume_token(LP);
      break;
    case RP:
      e = jj_consume_token(RP);
      break;
    case NUMS:
      e = jj_consume_token(NUMS);
      break;
    case A:
      e = jj_consume_token(A);
      break;
    case OF:
      e = jj_consume_token(OF);
      break;
    case NAMED:
      e = jj_consume_token(NAMED);
      break;
    case TYPE:
      e = jj_consume_token(TYPE);
      break;
    case ARCHTYPE:
      e = jj_consume_token(ARCHTYPE);
      break;
    case EXTERNALTYPE:
      e = jj_consume_token(EXTERNALTYPE);
      break;
    case is_a_subtype_of:
      e = jj_consume_token(is_a_subtype_of);
      break;
    case and_has:
      e = jj_consume_token(and_has);
      break;
    case and_an_instance:
      e = jj_consume_token(and_an_instance);
      break;
    case understands_the_following_commands:
      e = jj_consume_token(understands_the_following_commands);
      break;
    case which_initially_equals:
      e = jj_consume_token(which_initially_equals);
      break;
    case is_created_with_the_commands:
      e = jj_consume_token(is_created_with_the_commands);
      break;
    case this_file_uses:
      e = jj_consume_token(this_file_uses);
      break;
    case this_file_describes:
      e = jj_consume_token(this_file_describes);
      break;
    case a_Class:
      e = jj_consume_token(a_Class);
      break;
    case Functions:
      e = jj_consume_token(Functions);
      break;
    case a_Program:
      e = jj_consume_token(a_Program);
      break;
    case TO:
      e = jj_consume_token(TO);
      break;
    case TRUE:
      e = jj_consume_token(TRUE);
      break;
    case FALSE:
      e = jj_consume_token(FALSE);
      break;
    case DO:
      e = jj_consume_token(DO);
      break;
    case THEN:
      e = jj_consume_token(THEN);
      break;
    case IN:
      e = jj_consume_token(IN);
      break;
    case AS:
      e = jj_consume_token(AS);
      break;
    case and_in_the_event_of_a:
      e = jj_consume_token(and_in_the_event_of_a);
      break;
    case the_following_functions_make_use_of:
      e = jj_consume_token(the_following_functions_make_use_of);
      break;
    case WITH:
      e = jj_consume_token(WITH);
      break;
    case STRINGREF:
      e = jj_consume_token(STRINGREF);
      break;
    case INTREF:
      e = jj_consume_token(INTREF);
      break;
    case FLOATREF:
      e = jj_consume_token(FLOATREF);
      break;
    case BOOLREF:
      e = jj_consume_token(BOOLREF);
      break;
    case FUNCTIONREF:
      e = jj_consume_token(FUNCTIONREF);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {if (true) return e.image;}
    throw new Error("Missing return statement in function");
  }

//NL does nothing - done
  final public void NL() throws ParseException {
    label_1:
    while (true) {
      jj_consume_token(EOL);
      if (jj_2_1(2)) {
        ;
      } else {
        break label_1;
      }
    }
  }

//string returns string - done?
  final public String String() throws ParseException {
 Token e; String s;
    e = jj_consume_token(STRINGREF);
        s = e.image;
        s.substring(6); // take out "String:"
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

//int returns string num - done?
  final public String Int() throws ParseException {
 Token e;
    jj_consume_token(INTREF);
    e = jj_consume_token(NUMS);
        {if (true) return e.image;}
    throw new Error("Missing return statement in function");
  }

//float returns string num.num - done?
  final public String Float() throws ParseException {
 Token e; Token f; String s; String t;
    jj_consume_token(FLOATREF);
    e = jj_consume_token(NUMS);
    jj_consume_token(END);
    f = jj_consume_token(NUMS);
        {if (true) return (e.image + "." + f.image);}
    throw new Error("Missing return statement in function");
  }

//functioninit returns a string - done?
  final public String Functioninit() throws ParseException {
 Token e; ArrayList<String> s; String toRet = "";
         s = new ArrayList<String>();
    jj_consume_token(FUNCTIONREF);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
      case CHARS:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        e = jj_consume_token(IDENT);
                              s.add(e.image);
        break;
      case CHARS:
        e = jj_consume_token(CHARS);
                    s.add(e.image);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                toRet = toRet + s.get(0);
                for(int i = 1;i<s.size();i++){
                        toRet = toRet + " " + s.get(i);
                }
                {if (true) return toRet;}
    throw new Error("Missing return statement in function");
  }

//bool returns strings - done?
  final public String Bool() throws ParseException {
    jj_consume_token(BOOLREF);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
                    {if (true) return "true";}
      break;
    case FALSE:
      jj_consume_token(FALSE);
                          {if (true) return "false";}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//ftident returns object array with lots of stuff - done?
  final public Object[] FTIDENT() throws ParseException {
 String[] fullTypeName; String[] tmpres; String[][] parameterLimiters; ArrayList<String> tmpname; ArrayList<String[]> tmprestrictions; boolean seenres; Token e; Object[] returnarray;
    tmpname = new ArrayList<String>(); tmprestrictions = new ArrayList<String[]>();
    e = jj_consume_token(IDENT);
                tmpname.add(e.image); tmprestrictions.add(null);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OF:
      e = jj_consume_token(OF);
                    tmpname.add(e.image); tmprestrictions.add(null);
      label_3:
      while (true) {
        e = jj_consume_token(IDENT);
                               tmpname.add(e.image); seenres = false; tmpres = null;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LP:
          jj_consume_token(LP);
          tmpres = TIDENT();
                                                 seenres = true;
          jj_consume_token(RP);
          break;
        default:
          jj_la1[5] = jj_gen;
          ;
        }
                                 tmprestrictions.add(seenres?tmpres:null);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_3;
        }
      }
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    fullTypeName = new String[tmpname.size()];
        for(int i = 0; i < fullTypeName.length; i++){
           fullTypeName[i] = tmpname.get(i);
        }
        parameterLimiters = new String[tmprestrictions.size()][];
        for(int i = 0; i < parameterLimiters.length; i++){
           parameterLimiters[i] = tmprestrictions.get(i);
        }
        returnarray = new Object[2];
        returnarray[0] = fullTypeName;
        returnarray[1] = parameterLimiters;
        {if (true) return returnarray;}
    throw new Error("Missing return statement in function");
  }

//tident returns string[] type ident - done? 
  final public String[] TIDENT() throws ParseException {
 String[] fullTypeName; Token e; ArrayList<String> tmpname;
    tmpname = new ArrayList<String>();
    e = jj_consume_token(IDENT);
                tmpname.add(e.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OF:
      e = jj_consume_token(OF);
                                                  tmpname.add(e.image);
      label_4:
      while (true) {
        if (jj_2_2(2)) {
          e = jj_consume_token(IDENT);
                                                                                                   tmpname.add(e.image);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENT:
            e = jj_consume_token(IDENT);
                                                                                                                                      tmpname.add(e.image);
            e = jj_consume_token(OF);
                                                                                                                                                                      tmpname.add(e.image);
            break;
          default:
            jj_la1[8] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENT:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
         fullTypeName = new String[tmpname.size()];
                for(int i = 0; i < fullTypeName.length; i++){
                        fullTypeName[i] = tmpname.get(i); }
        {if (true) return fullTypeName;}
    throw new Error("Missing return statement in function");
  }

//file - done?
  final public HCISRFileAST FILE() throws ParseException {
 HCISRFileAST f;
    jj_consume_token(this_file_describes);
    f = Fileh();
                                       {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

//fileh - done?
  final public HCISRFileAST Fileh() throws ParseException {
 HCISRFileAST f; String[] filestoimport; HCISRClassAST c; HCISRFunctionFileAST fun; HCISRStatementAST[] s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case a_Class:
      jj_consume_token(a_Class);
      NL();
      filestoimport = Importbody();
      jj_consume_token(END);
      NL();
      c = Class();
                                                                        {if (true) return new HCISRFileAST(filestoimport, c);}
      break;
    case Functions:
      jj_consume_token(Functions);
      NL();
      filestoimport = Importbody();
      jj_consume_token(END);
      NL();
      fun = Function();
                                                                                {if (true) return new HCISRFileAST(filestoimport, fun);}
      break;
    case a_Program:
      jj_consume_token(a_Program);
      NL();
      filestoimport = Importbody();
      jj_consume_token(END);
      NL();
      s = Program();
                                                                             {if (true) return new HCISRFileAST(filestoimport, s);}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//fileh -> importbody - gets imports and put into string[] - done?
  final public String[] Importbody() throws ParseException {
 String[] imports; String tmp; ArrayList<String> tobuild;
    tobuild = new ArrayList<String>();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case this_file_uses:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
      tmp = Import();
                                                        tobuild.add(tmp);
    }
         imports = new String[tobuild.size()];
                for(int i = 0; i<tobuild.size(); i++)
                {
                   imports[i] = tobuild.get(i);
                }
                {if (true) return imports;}
    throw new Error("Missing return statement in function");
  }

//fileh -> importbody -> import - get import one at a time - done?
  final public String Import() throws ParseException {
 Token e;
    jj_consume_token(this_file_uses);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARS:
      e = jj_consume_token(CHARS);
      break;
    case IDENT:
      e = jj_consume_token(IDENT);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    NL();
                                                      {if (true) return e.image;}
    throw new Error("Missing return statement in function");
  }

//class - done?
  final public HCISRClassAST Class() throws ParseException {
 int classClassification; String[] fullTypeName; String[][] parameterLimiters; String[] fullSuperTypeName; HCISRVariableAST[] instanceVariableList;HCISRMethodAST[] instanceMethodList;HCISRConstructorAST[] fullConstructorList;String methodSelfReference = "";String constructorSelfReference = ""; /*starting tmps*/ Object[] headerReturn; Object[] methodReturn = null; Object[] constructorReturn = null;
         instanceVariableList = null; instanceMethodList = null; fullConstructorList = null;
    headerReturn = Header();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case and_has:
      instanceVariableList = Data();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    if (jj_2_3(3)) {
      methodReturn = Methods();
    } else {
      ;
    }
    if (jj_2_4(3)) {
      constructorReturn = Constructor();
    } else {
      ;
    }
    jj_consume_token(END);
    NL();
                //get info from header
                classClassification = ((Integer)(headerReturn[0]));
                fullTypeName = ((String[])(headerReturn[1]));
                parameterLimiters = ((String[][])(headerReturn[2]));
                fullSuperTypeName = ((String[])(headerReturn[3]));
                //return a zero <strictly non-null> constructor if there was no instance of data,methods, and/or constructor
                if (instanceVariableList == null) { instanceVariableList = new HCISRVariableAST[0];}
                if(methodReturn!=null){
                        methodSelfReference = ((String)(methodReturn[0]));
                        instanceMethodList = ((HCISRMethodAST[])(methodReturn[1]));
                }
                if (instanceMethodList == null) { instanceMethodList = new HCISRMethodAST[0];}
                if(constructorReturn!=null){
                        constructorSelfReference = ((String)(constructorReturn[0]));
                        fullConstructorList = ((HCISRConstructorAST[])(constructorReturn[1]));
                }
                if (fullConstructorList == null) { fullConstructorList = new HCISRConstructorAST[0];}

                {if (true) return new HCISRClassAST(classClassification, fullTypeName, parameterLimiters, fullSuperTypeName, instanceVariableList, instanceMethodList, fullConstructorList, methodSelfReference, constructorSelfReference);}
    throw new Error("Missing return statement in function");
  }

//class -> header - done?
  final public Object[] Header() throws ParseException {
 String[] fullTypeName; String[] fullSuperTypeName; Object[] filetypeident; String[][] parameterLimiters; int classtype; Object[] returnarray;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TYPE:
      jj_consume_token(TYPE);
            classtype = 0;
      break;
    case ARCHTYPE:
      jj_consume_token(ARCHTYPE);
                                       classtype = 1;
      break;
    case EXTERNALTYPE:
      jj_consume_token(EXTERNALTYPE);
                                                                      classtype = 2;
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    filetypeident = FTIDENT();
    jj_consume_token(is_a_subtype_of);
    fullSuperTypeName = TIDENT();
    NL();
                returnarray = new Object[4];
                fullTypeName = ((String[])(filetypeident[0]));
                parameterLimiters = ((String[][])(filetypeident[1]));
                returnarray[0] = classtype;
                returnarray[1] = fullTypeName;
                returnarray[2] = parameterLimiters;
                returnarray[3] = fullSuperTypeName;
                {if (true) return returnarray;}
    throw new Error("Missing return statement in function");
  }

//class -> data - done?
  final public HCISRVariableAST[] Data() throws ParseException {
 HCISRVariableAST[] databodyreturn;
    Dataheader();
    databodyreturn = Databody();
    jj_consume_token(END);
    NL();
        {if (true) return databodyreturn;}
    throw new Error("Missing return statement in function");
  }

//data -> data header - does nothing - done
  final public void Dataheader() throws ParseException {
    jj_consume_token(and_has);
    NL();
  }

//data -> Databody - done?
  final public HCISRVariableAST[] Databody() throws ParseException {
 String[] typeDeclaration; /*String variableName;*/ int initializedType; String initializedValue; Token e; ArrayList<HCISRVariableAST> returnarray;
         returnarray = new ArrayList<HCISRVariableAST>();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_6;
      }
         initializedType = -1; initializedValue = null;
      jj_consume_token(A);
      typeDeclaration = TIDENT();
      jj_consume_token(NAMED);
      e = jj_consume_token(IDENT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case which_initially_equals:
        jj_consume_token(which_initially_equals);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRINGREF:
          initializedValue = String();
                                                           initializedType = 0;
          break;
        default:
          jj_la1[17] = jj_gen;
          if (jj_2_5(2)) {
            initializedValue = Int();
                                                           initializedType = 1;
          } else if (jj_2_6(2)) {
            initializedValue = Float();
                                                           initializedType = 2;
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case FUNCTIONREF:
              initializedValue = Functioninit();
                                                           initializedType = 3;
              break;
            case BOOLREF:
              initializedValue = Bool();
                                                           initializedType = 4;
              break;
            default:
              jj_la1[18] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      NL();
          returnarray.add(new HCISRVariableAST(typeDeclaration, e.image, initializedType, initializedValue));
    }
          {if (true) return returnarray.toArray(new HCISRVariableAST[returnarray.size()]);}
    throw new Error("Missing return statement in function");
  }

//class -> methods - done?
  final public Object[] Methods() throws ParseException {
 Object[] returnarray; String methodselfreference; HCISRMethodAST[] instanceMethodList;
    methodselfreference = Methodhead();
    instanceMethodList = Methodbodies();
    jj_consume_token(END);
    NL();
                returnarray = new Object[2];
                returnarray[0] = methodselfreference;
                returnarray[1] = instanceMethodList;
                {if (true) return returnarray;}
    throw new Error("Missing return statement in function");
  }

//Methods -> methodhead - done?
  final public String Methodhead() throws ParseException {
 String methodselfreference; Token e;
    jj_consume_token(and_an_instance);
    e = jj_consume_token(IDENT);
    jj_consume_token(understands_the_following_commands);
    NL();
                methodselfreference = e.image;
                {if (true) return methodselfreference;}
    throw new Error("Missing return statement in function");
  }

//Methods -> Methodbodies - returns array of HCISRMethodAST - done?
  final public HCISRMethodAST[] Methodbodies() throws ParseException {
 HCISRMethodAST m; ArrayList<HCISRMethodAST> marray;
         marray = new ArrayList<HCISRMethodAST>();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENT:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_7;
      }
      m = Methoddec();
                     marray.add(m);
    }
         {if (true) return marray.toArray(new HCISRMethodAST[marray.size()]);}
    throw new Error("Missing return statement in function");
  }

//Methods -> Methodbodies -> Methoddec - returns a defined or declared method ast - done?
  final public HCISRMethodAST Methoddec() throws ParseException {
 Object[] Methodidreturn; Object[] Codebodyreturn; String instanceName; String[] methodSignature; String[][] parameterRestrictions;
    //if codebody is returnsdec then it is declared if its codeblock it is defined - HCISRDefinedMethod and HCISRDeclaredMethod
       Methodidreturn = Methodid();
    Codebodyreturn = Codebody();
    jj_consume_token(END);
    NL();
                instanceName = (String)(Methodidreturn[0]);
                methodSignature = (String[])(Methodidreturn[1]);
                parameterRestrictions = (String[][])(Methodidreturn[2]);

                if (((Boolean)(Codebodyreturn[0])) == false)
                     { {if (true) return new HCISRDeclaredMethodAST(instanceName, methodSignature, parameterRestrictions,((HCISRReturnsDeclarationAST)(Codebodyreturn[1])));}}
                else { {if (true) return new HCISRDefinedMethodAST(instanceName, methodSignature, parameterRestrictions, ((HCISRCodeBlockAST)(Codebodyreturn[1])));}}
    throw new Error("Missing return statement in function");
  }

//methoddec -> methodid - done?
  final public Object[] Methodid() throws ParseException {
 Token e; Token f; String instName; String[] sig; String[][] typeRestrictions; ArrayList<String> sig1; ArrayList<String[]> typeRes2; String anytmp; String[] tidenttmp;
        sig1 = new ArrayList<String>();
        typeRes2 = new ArrayList<String[]>();
    e = jj_consume_token(IDENT);
                instName = e.image; sig1.add(e.image); typeRes2.add(null);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END:
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case otherwise:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case RETURNS:
      case RETURN:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        anytmp = Any();
                         sig1.add(anytmp); typeRes2.add(null);
        break;
      case IDENT:
        f = jj_consume_token(IDENT);
        jj_consume_token(LP);
        tidenttmp = TIDENT();
        jj_consume_token(RP);
                                                      sig1.add(f.image); typeRes2.add(tidenttmp);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END:
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case otherwise:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case RETURNS:
      case RETURN:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_8;
      }
    }
    NL();
                sig = new String[sig1.size()];
                for (int i = 0; i < sig.length; i++) {sig[i] = sig1.get(i);}
                typeRestrictions = new String[typeRes2.size()][];
                for (int i = 0; i < typeRestrictions.length; i++) {typeRestrictions[i] = typeRes2.get(i);}
                {if (true) return new Object[]{instName, sig, typeRestrictions};}
    throw new Error("Missing return statement in function");
  }

//methods -> codebody - returns {isdefined, returnsdec/codeblock} - done?
  final public Object[] Codebody() throws ParseException {
 HCISRReturnsDeclarationAST tidentreturn; HCISRCodeBlockAST codeblockreturn; Object[] returnarray;
         returnarray = new Object[2];
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RETURNS:
      tidentreturn = Returnsdec();
                                returnarray[0]=false; returnarray[1]=tidentreturn;
      break;
    case OF:
    case A:
    case NAMED:
    case TYPE:
    case ARCHTYPE:
    case EXTERNALTYPE:
    case is_a_subtype_of:
    case and_has:
    case and_an_instance:
    case understands_the_following_commands:
    case which_initially_equals:
    case is_created_with_the_commands:
    case this_file_uses:
    case this_file_describes:
    case a_Class:
    case Functions:
    case a_Program:
    case define_a:
    case SET:
    case TO:
    case IF:
    case TRUE:
    case FALSE:
    case FOR_ALL:
    case DO:
    case WHILE:
    case COMPLAIN_ABOUT:
    case LABEL:
    case GOTO:
    case NOTE:
    case RETURN:
    case THEN:
    case IN:
    case AS:
    case WITH:
    case STRINGREF:
    case INTREF:
    case FLOATREF:
    case FUNCTIONREF:
    case BOOLREF:
    case make_a_new:
    case and_in_the_event_of_a:
    case the_following_functions_make_use_of:
    case IDENT:
    case NUMS:
    case LP:
    case RP:
    case CHARS:
      codeblockreturn = Codeblock();
                                         returnarray[0]=true; returnarray[1] = codeblockreturn;
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         {if (true) return returnarray;}
    throw new Error("Missing return statement in function");
  }

//methods -> codebody -> returnsdec - returns returns dec ast - done?
  final public HCISRReturnsDeclarationAST Returnsdec() throws ParseException {
 String[] tidentreturn;
    jj_consume_token(RETURNS);
    tidentreturn = TIDENT();
    NL();
                                            {if (true) return new HCISRReturnsDeclarationAST(tidentreturn);}
    throw new Error("Missing return statement in function");
  }

//constructor - done?
  final public Object[] Constructor() throws ParseException {
 Object[] returnarray; String constructorselfreference; HCISRConstructorAST[] constructorbodiesreturn;
    constructorselfreference = Constructorhead();
    constructorbodiesreturn = Constructorbodies();
    jj_consume_token(END);
    NL();
                returnarray = new Object[2];
                returnarray[0] = constructorselfreference;
                returnarray[1] = constructorbodiesreturn;
                {if (true) return returnarray;}
    throw new Error("Missing return statement in function");
  }

//constructor -> constructorhead returns string constructorselfreference - done?
  final public String Constructorhead() throws ParseException {
 String constructorselfreference; Token e;
    jj_consume_token(and_an_instance);
    e = jj_consume_token(IDENT);
    jj_consume_token(is_created_with_the_commands);
    NL();
                constructorselfreference = e.image;
                constructorvar = constructorselfreference;
                {if (true) return constructorselfreference;}
    throw new Error("Missing return statement in function");
  }

//constructor -> constructorbodies returns array of constructor ast's - done?
  final public HCISRConstructorAST[] Constructorbodies() throws ParseException {
 HCISRConstructorAST c; ArrayList<HCISRConstructorAST> returnarray;
         returnarray = new ArrayList<HCISRConstructorAST>();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case make_a_new:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_9;
      }
      c = Constructordec();
                          returnarray.add(c);
    }
         {if (true) return returnarray.toArray(new HCISRConstructorAST[returnarray.size()]);}
    throw new Error("Missing return statement in function");
  }

//constructor -> constructorbodies -> constructordec returns a new constructor AST - done?
  final public HCISRConstructorAST Constructordec() throws ParseException {
 Object[] constructoridreturn; Object[] codebodyreturn; String[] createdType; String[] methodSignature; String[][] typeRestrictions;
    constructoridreturn = Constructorid();
    codebodyreturn = Codebody();
    jj_consume_token(END);
    NL();
                createdType = ((String[])(constructoridreturn[0]));
                methodSignature = ((String[])(constructoridreturn[1]));
                typeRestrictions = ((String[][])(constructoridreturn[2]));
                //return declared or defined constructorAST
                if (((Boolean)(codebodyreturn[0])) == false)
                        {{if (true) return (new HCISRDeclaredConstructorAST(constructorvar, createdType, methodSignature, typeRestrictions, ((HCISRReturnsDeclarationAST)(codebodyreturn[1])) ));}}
                else {{if (true) return (new HCISRDefinedConstructorAST(constructorvar, createdType, methodSignature, typeRestrictions, ((HCISRCodeBlockAST)(codebodyreturn[1])) ));}}
    throw new Error("Missing return statement in function");
  }

//constructor -> constructorbodies -> constructordec -> constructorid - returns object {createdType, methodsig, typeres} - done?
  final public Object[] Constructorid() throws ParseException {
 Token e; String[] createdType; String[] methodSignature; String[][] typeRestrictions; String anytmp; ArrayList<String> msig1 = new ArrayList<String>(); ArrayList<String[]> tres1 = new ArrayList<String[]>(); String[] tidenttmp;
    jj_consume_token(make_a_new);
    createdType = TIDENT();
                                        for(String s: createdType){msig1.add(s); tres1.add(null);}
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WITH:
      jj_consume_token(WITH);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case END:
        case OF:
        case A:
        case NAMED:
        case TYPE:
        case ARCHTYPE:
        case EXTERNALTYPE:
        case is_a_subtype_of:
        case and_has:
        case and_an_instance:
        case understands_the_following_commands:
        case which_initially_equals:
        case is_created_with_the_commands:
        case this_file_uses:
        case this_file_describes:
        case a_Class:
        case Functions:
        case a_Program:
        case define_a:
        case SET:
        case TO:
        case IF:
        case TRUE:
        case FALSE:
        case otherwise:
        case FOR_ALL:
        case DO:
        case WHILE:
        case COMPLAIN_ABOUT:
        case LABEL:
        case GOTO:
        case NOTE:
        case RETURNS:
        case RETURN:
        case THEN:
        case IN:
        case AS:
        case WITH:
        case STRINGREF:
        case INTREF:
        case FLOATREF:
        case FUNCTIONREF:
        case BOOLREF:
        case make_a_new:
        case and_in_the_event_of_a:
        case the_following_functions_make_use_of:
        case IDENT:
        case NUMS:
        case LP:
        case RP:
        case CHARS:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_10;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case END:
        case OF:
        case A:
        case NAMED:
        case TYPE:
        case ARCHTYPE:
        case EXTERNALTYPE:
        case is_a_subtype_of:
        case and_has:
        case and_an_instance:
        case understands_the_following_commands:
        case which_initially_equals:
        case is_created_with_the_commands:
        case this_file_uses:
        case this_file_describes:
        case a_Class:
        case Functions:
        case a_Program:
        case define_a:
        case SET:
        case TO:
        case IF:
        case TRUE:
        case FALSE:
        case otherwise:
        case FOR_ALL:
        case DO:
        case WHILE:
        case COMPLAIN_ABOUT:
        case LABEL:
        case GOTO:
        case NOTE:
        case RETURNS:
        case RETURN:
        case THEN:
        case IN:
        case AS:
        case WITH:
        case STRINGREF:
        case INTREF:
        case FLOATREF:
        case FUNCTIONREF:
        case BOOLREF:
        case make_a_new:
        case and_in_the_event_of_a:
        case the_following_functions_make_use_of:
        case NUMS:
        case LP:
        case RP:
        case CHARS:
          anytmp = Any();
                                 msig1.add(anytmp); tres1.add(null);
          break;
        case IDENT:
          e = jj_consume_token(IDENT);
          jj_consume_token(LP);
          tidenttmp = TIDENT();
          jj_consume_token(RP);
                                                             msig1.add(e.image); tres1.add(tidenttmp);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    NL();
                {if (true) return new Object[]{createdType, msig1.toArray(new String[msig1.size()]), tres1.toArray(new String[tres1.size()][])};}
    throw new Error("Missing return statement in function");
  }

//file -> function returns a function ast - done?
  final public HCISRFunctionFileAST Function() throws ParseException {
 HCISRVariableAST[] globalDataDeclaration; HCISRFunctionAST[] functionDeclarations;
    globalDataDeclaration = Fdata();
    functionDeclarations = Funcs();
         {if (true) return new HCISRFunctionFileAST(globalDataDeclaration, functionDeclarations);}
    throw new Error("Missing return statement in function");
  }

//function -> fdata returns variable ast - done?
  final public HCISRVariableAST[] Fdata() throws ParseException {
 HCISRVariableAST[] databodyreturn;
    Fdatahead();
    databodyreturn = Databody();
    jj_consume_token(END);
    NL();
                                                          {if (true) return databodyreturn;}
    throw new Error("Missing return statement in function");
  }

//function -> fdata -> fdatahead does nothing - done?
  final public void Fdatahead() throws ParseException {
    jj_consume_token(the_following_functions_make_use_of);
    NL();
  }

//function -> fdata -> funcs returns an array of function ast - done?
  final public HCISRFunctionAST[] Funcs() throws ParseException {
 HCISRFunctionAST f; ArrayList<HCISRFunctionAST> returnarray;
         returnarray = new ArrayList<HCISRFunctionAST>();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case TO:
      case TRUE:
      case FALSE:
      case DO:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_11;
      }
      f = Functiondec();
                        returnarray.add(f);
    }
         {if (true) return returnarray.toArray(new HCISRFunctionAST[returnarray.size()]);}
    throw new Error("Missing return statement in function");
  }

//function -> fdata -> functiondec returns new function ast - done?
  final public HCISRFunctionAST Functiondec() throws ParseException {
 Object[] codebodyreturn; Object[] functionidreturn; String[] methodSignature; String[][] typeRestrictions;
    functionidreturn = Functionid();
    codebodyreturn = Codebody();
    jj_consume_token(END);
    NL();
                methodSignature = ((String[])(functionidreturn[0]));
                typeRestrictions = ((String[][])(functionidreturn[1]));
                if (((Boolean)(codebodyreturn[0])) == false){
                        {if (true) return new HCISRDeclaredFunctionAST(methodSignature, typeRestrictions, ((HCISRReturnsDeclarationAST)(codebodyreturn[1])));}}
                 else { {if (true) return new HCISRDefinedFunctionAST(methodSignature, typeRestrictions, ((HCISRCodeBlockAST)(codebodyreturn[1])));} }
    throw new Error("Missing return statement in function");
  }

//function -> fdata -> functiondec -> function id returns object array - done?
  final public Object[] Functionid() throws ParseException {
 String[] methodSignature; String[][] typeRestrictions; String s; Token e; String[] tidentreturn; String anytmp; ArrayList<String> msig1; ArrayList<String[]> tres1;
         msig1 = new ArrayList<String>(); tres1 = new ArrayList<String[]>();
    s = Anyfirst();
                   msig1.add(s); tres1.add(null);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END:
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case otherwise:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case RETURNS:
      case RETURN:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END:
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case otherwise:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case RETURNS:
      case RETURN:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        anytmp = Any();
                         msig1.add(anytmp); tres1.add(null);
        break;
      case IDENT:
        e = jj_consume_token(IDENT);
        jj_consume_token(LP);
        tidentreturn = TIDENT();
        jj_consume_token(RP);
                                                       msig1.add(e.image); tres1.add(tidentreturn);
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    NL();
         {if (true) return new Object[]{msig1.toArray(new String[msig1.size()]), tres1.toArray(new String[tres1.size()][])};}
    throw new Error("Missing return statement in function");
  }

//file -> program - done?
  final public HCISRStatementAST[] Program() throws ParseException {
 HCISRStatementAST s; ArrayList<HCISRStatementAST> returnarray1; HCISRStatementAST[] returnarray;
                  returnarray1 = new ArrayList<HCISRStatementAST>();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[31] = jj_gen;
        break label_13;
      }
      s = Statement();
                     returnarray1.add(s);
    }
         {if (true) return returnarray1.toArray(new HCISRStatementAST[returnarray1.size()]);}
    throw new Error("Missing return statement in function");
  }

//* -> codeblock returns HCISRCodeblock - done?
  final public HCISRCodeBlockAST Codeblock() throws ParseException {
 HCISRStatementAST[] codeConts; HCISRReturnsClauseAST toRet; HCISRCatchClauseAST[] errCor; ArrayList<HCISRStatementAST> cc1; HCISRStatementAST s; HCISRCatchClauseAST c; ArrayList<HCISRCatchClauseAST> erc1;
         cc1 = new ArrayList<HCISRStatementAST>(); erc1 = new ArrayList<HCISRCatchClauseAST>();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_14;
      }
      s = Statement();
                     cc1.add(s);
    }
    toRet = Returncall();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case and_in_the_event_of_a:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_15;
      }
      c = Catchcall();
                                                                            erc1.add(c);
    }
                {if (true) return new HCISRCodeBlockAST(cc1.toArray(new HCISRStatementAST[cc1.size()]), toRet, erc1.toArray(new HCISRCatchClauseAST[erc1.size()]));}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement - returns statement ast - done?
  final public HCISRStatementAST Statement() throws ParseException {
 HCISRStatementAST callreturn;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      callreturn = Methodcall();
      break;
    case define_a:
    case SET:
    case IF:
    case FOR_ALL:
    case WHILE:
    case COMPLAIN_ABOUT:
    case LABEL:
    case GOTO:
    case NOTE:
      callreturn = Structurecall();
      break;
    case OF:
    case A:
    case NAMED:
    case TYPE:
    case ARCHTYPE:
    case EXTERNALTYPE:
    case is_a_subtype_of:
    case and_has:
    case and_an_instance:
    case understands_the_following_commands:
    case which_initially_equals:
    case is_created_with_the_commands:
    case this_file_uses:
    case this_file_describes:
    case a_Class:
    case Functions:
    case a_Program:
    case TO:
    case TRUE:
    case FALSE:
    case DO:
    case THEN:
    case IN:
    case AS:
    case WITH:
    case STRINGREF:
    case INTREF:
    case FLOATREF:
    case FUNCTIONREF:
    case BOOLREF:
    case and_in_the_event_of_a:
    case the_following_functions_make_use_of:
    case NUMS:
    case LP:
    case RP:
    case CHARS:
      callreturn = Functioncall();
      break;
    case make_a_new:
      callreturn = Constructorcall();
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         {if (true) return callreturn;}
    throw new Error("Missing return statement in function");
  }

//codeblock ->  statement -> methodcall returns methodcallast(string[]) - done?
  final public HCISRMethodCallAST Methodcall() throws ParseException {
 String[] methodSignature; Token e; ArrayList<String> sig; String tmp;
         sig = new ArrayList<String>();
    e = jj_consume_token(IDENT);
                sig.add(e.image);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END:
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case otherwise:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case RETURNS:
      case RETURN:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END:
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case otherwise:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case RETURNS:
      case RETURN:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        tmp = Any();
                                                 sig.add(tmp);
        break;
      case IDENT:
        e = jj_consume_token(IDENT);
                                                                              sig.add(e.image);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    NL();
                methodSignature = sig.toArray(new String[sig.size()]);
                {if (true) return new HCISRMethodCallAST(methodSignature);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> constructorcall returns constructor call ast - done?
  final public HCISRConstructorCallAST Constructorcall() throws ParseException {
 String[] methodSignature; String[] typeIdentifier; ArrayList<String> typId1; String tmp; Token e;
         typId1 = new ArrayList<String>();
    jj_consume_token(make_a_new);
    methodSignature = TIDENT();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WITH:
      jj_consume_token(WITH);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case END:
        case OF:
        case A:
        case NAMED:
        case TYPE:
        case ARCHTYPE:
        case EXTERNALTYPE:
        case is_a_subtype_of:
        case and_has:
        case and_an_instance:
        case understands_the_following_commands:
        case which_initially_equals:
        case is_created_with_the_commands:
        case this_file_uses:
        case this_file_describes:
        case a_Class:
        case Functions:
        case a_Program:
        case define_a:
        case SET:
        case TO:
        case IF:
        case TRUE:
        case FALSE:
        case otherwise:
        case FOR_ALL:
        case DO:
        case WHILE:
        case COMPLAIN_ABOUT:
        case LABEL:
        case GOTO:
        case NOTE:
        case RETURNS:
        case RETURN:
        case THEN:
        case IN:
        case AS:
        case WITH:
        case STRINGREF:
        case INTREF:
        case FLOATREF:
        case FUNCTIONREF:
        case BOOLREF:
        case make_a_new:
        case and_in_the_event_of_a:
        case the_following_functions_make_use_of:
        case IDENT:
        case NUMS:
        case LP:
        case RP:
        case CHARS:
          ;
          break;
        default:
          jj_la1[37] = jj_gen;
          break label_17;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case END:
        case OF:
        case A:
        case NAMED:
        case TYPE:
        case ARCHTYPE:
        case EXTERNALTYPE:
        case is_a_subtype_of:
        case and_has:
        case and_an_instance:
        case understands_the_following_commands:
        case which_initially_equals:
        case is_created_with_the_commands:
        case this_file_uses:
        case this_file_describes:
        case a_Class:
        case Functions:
        case a_Program:
        case define_a:
        case SET:
        case TO:
        case IF:
        case TRUE:
        case FALSE:
        case otherwise:
        case FOR_ALL:
        case DO:
        case WHILE:
        case COMPLAIN_ABOUT:
        case LABEL:
        case GOTO:
        case NOTE:
        case RETURNS:
        case RETURN:
        case THEN:
        case IN:
        case AS:
        case WITH:
        case STRINGREF:
        case INTREF:
        case FLOATREF:
        case FUNCTIONREF:
        case BOOLREF:
        case make_a_new:
        case and_in_the_event_of_a:
        case the_following_functions_make_use_of:
        case NUMS:
        case LP:
        case RP:
        case CHARS:
          tmp = Any();
                      typId1.add(tmp);
          break;
        case IDENT:
          e = jj_consume_token(IDENT);
                                                       typId1.add(e.image);
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    NL();
                typeIdentifier = typId1.toArray(new String[typId1.size()]);
                {if (true) return new HCISRConstructorCallAST(methodSignature, typeIdentifier);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> structurecall returns statement ast - done?
  final public HCISRStatementAST Structurecall() throws ParseException {
 HCISRStatementAST callreturn;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case define_a:
      callreturn = Definecall();
      break;
    case SET:
      callreturn = Setcall();
      break;
    case IF:
      callreturn = Ifcall();
      break;
    case FOR_ALL:
      callreturn = Forcall();
      break;
    case WHILE:
      callreturn = Whilecall();
      break;
    case COMPLAIN_ABOUT:
      callreturn = Complaincall();
      break;
    case LABEL:
      callreturn = Labelcall();
      break;
    case GOTO:
      callreturn = Gotocall();
      break;
    case NOTE:
      callreturn = Notecall();
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                                                                                                                                                                                                                  {if (true) return callreturn;}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> definecall returns statement ast - done?
  final public HCISRStatementAST Definecall() throws ParseException {
 String[] typeIdentifier; String variableName; String initialValue = ""; int initialType = -1; Token e;
    jj_consume_token(define_a);
    typeIdentifier = TIDENT();
    jj_consume_token(NAMED);
    e = jj_consume_token(IDENT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case which_initially_equals:
      jj_consume_token(which_initially_equals);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRINGREF:
        initialValue = String();
                                                       initialType = 0;
        break;
      case INTREF:
        initialValue = Int();
                                                       initialType = 1;
        break;
      case FLOATREF:
        initialValue = Float();
                                                       initialType = 2;
        break;
      case FUNCTIONREF:
        initialValue = Functioninit();
                                                       initialType = 3;
        break;
      case BOOLREF:
        initialValue = Bool();
                                                       initialType = 4;
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    NL();
                variableName = e.image;
                {if (true) return new HCISRDefineCallAST(typeIdentifier, variableName, initialValue, initialType);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> setcall returns statement ast - done?
  final public HCISRStatementAST Setcall() throws ParseException {
 HCISRMethodCallAST methodcallreturn = null; HCISRFunctionCallAST functioncallreturn = null; HCISRConstructorCallAST constructorcallreturn = null; Token e;
    jj_consume_token(SET);
    e = jj_consume_token(IDENT);

    jj_consume_token(TO);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      methodcallreturn = Methodcall();
      break;
    case OF:
    case A:
    case NAMED:
    case TYPE:
    case ARCHTYPE:
    case EXTERNALTYPE:
    case is_a_subtype_of:
    case and_has:
    case and_an_instance:
    case understands_the_following_commands:
    case which_initially_equals:
    case is_created_with_the_commands:
    case this_file_uses:
    case this_file_describes:
    case a_Class:
    case Functions:
    case a_Program:
    case TO:
    case TRUE:
    case FALSE:
    case DO:
    case THEN:
    case IN:
    case AS:
    case WITH:
    case STRINGREF:
    case INTREF:
    case FLOATREF:
    case FUNCTIONREF:
    case BOOLREF:
    case and_in_the_event_of_a:
    case the_following_functions_make_use_of:
    case NUMS:
    case LP:
    case RP:
    case CHARS:
      functioncallreturn = Functioncall();
      break;
    case make_a_new:
      constructorcallreturn = Constructorcall();
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (methodcallreturn != null) {if (true) return new HCISRSetCallMethodAST(e.image, methodcallreturn);}
           else if (functioncallreturn != null) {if (true) return new HCISRSetCallFunctionAST(e.image, functioncallreturn);}
           else if (constructorcallreturn != null) {if (true) return new HCISRSetCallConstructorAST(e.image, constructorcallreturn);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> ifcall returns statementast - done?
  final public HCISRStatementAST Ifcall() throws ParseException {
 String booleanID; HCISRStatementAST[] trueCommands; HCISRStatementAST[] falseCommands = null;
    booleanID = Conditional();
    trueCommands = Ifclause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case otherwise:
      falseCommands = Elseclause();
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
                if (falseCommands == null) {falseCommands = new HCISRStatementAST[0];}
                {if (true) return new HCISRIfCallAST(booleanID, trueCommands, falseCommands);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> ifcall -> conditional returns string booleanID - done?
  final public String Conditional() throws ParseException {
 Token e;
    jj_consume_token(IF);
    e = jj_consume_token(IDENT);
    jj_consume_token(THEN);
    NL();
         {if (true) return e.image;}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> ifcall -> Ifclause returns statement ast array - done?
  final public HCISRStatementAST[] Ifclause() throws ParseException {
 HCISRStatementAST s; ArrayList<HCISRStatementAST> statementarray;
         statementarray = new ArrayList<HCISRStatementAST>();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_18;
      }
      s = Statement();
                     statementarray.add(s);
    }
    jj_consume_token(END);
    NL();
         {if (true) return statementarray.toArray(new HCISRStatementAST[statementarray.size()]);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> ifcall -> elseclause returns statement ast array - done?
  final public HCISRStatementAST[] Elseclause() throws ParseException {
 HCISRStatementAST s; ArrayList<HCISRStatementAST> statementarray;
         statementarray = new ArrayList<HCISRStatementAST>();
    jj_consume_token(otherwise);
    NL();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_19;
      }
      s = Statement();
                                      statementarray.add(s);
    }
    jj_consume_token(END);
    NL();
         {if (true) return statementarray.toArray(new HCISRStatementAST[statementarray.size()]);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> forcall returns for call ast - done?
  final public HCISRStatementAST Forcall() throws ParseException {
 String[] typeIdentifier; String variableIdentifier; String listIdentifier; Object[] fordecreturn; ArrayList<HCISRStatementAST> loopCommands; HCISRStatementAST s;
         loopCommands = new ArrayList<HCISRStatementAST>();
    fordecreturn = Fordec();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_20;
      }
      s = Statement();
                                             loopCommands.add(s);
    }
    jj_consume_token(END);
    NL();
                typeIdentifier = ((String[])(fordecreturn[0]));
                variableIdentifier = ((String)(fordecreturn[1]));
                listIdentifier = ((String)(fordecreturn[2]));
                {if (true) return new HCISRForCallAST(typeIdentifier, variableIdentifier, listIdentifier, loopCommands.toArray(new HCISRStatementAST[loopCommands.size()]));}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> forcall -> fordec returns {typeident[], variableident, listident} - done?
  final public Object[] Fordec() throws ParseException {
 String[] typeIdentifier; Token variableIdentifier; Token listIdentifier;
    jj_consume_token(FOR_ALL);
    typeIdentifier = TIDENT();
    jj_consume_token(NAMED);
    variableIdentifier = jj_consume_token(IDENT);
    jj_consume_token(IN);
    listIdentifier = jj_consume_token(IDENT);
    jj_consume_token(DO);
    NL();
         {if (true) return new Object[] {typeIdentifier, variableIdentifier.image, listIdentifier.image};}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> whilecall - done?
  final public HCISRStatementAST Whilecall() throws ParseException {
 String booleanID; ArrayList<HCISRStatementAST> loopCommands; HCISRStatementAST s;
         loopCommands = new ArrayList<HCISRStatementAST>();
    booleanID = Whiledec();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_21;
      }
      s = Statement();
                                            loopCommands.add(s);
    }
    jj_consume_token(END);
    NL();
          {if (true) return new HCISRWhileCallAST(booleanID, loopCommands.toArray(new HCISRStatementAST[loopCommands.size()]));}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> whilecall -> whiledec returns booleanID string - done?
  final public String Whiledec() throws ParseException {
 Token e;
    jj_consume_token(WHILE);
    e = jj_consume_token(IDENT);
    jj_consume_token(DO);
    NL();
         {if (true) return e.image;}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> complaincall returns complain call ast - done?
  final public HCISRStatementAST Complaincall() throws ParseException {
 Token errorIdentifier;
    jj_consume_token(COMPLAIN_ABOUT);
    errorIdentifier = jj_consume_token(IDENT);
    NL();
         {if (true) return new HCISRComplainCallAST(errorIdentifier.image);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> labelcall returns label call ast - done?
  final public HCISRStatementAST Labelcall() throws ParseException {
 Token labelName;
    jj_consume_token(LABEL);
    labelName = jj_consume_token(IDENT);
    NL();
         {if (true) return new HCISRLabelCallAST(labelName.image);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> gotocall returns goto call ast - done?
  final public HCISRStatementAST Gotocall() throws ParseException {
 Token locationIdentifier;
    jj_consume_token(GOTO);
    locationIdentifier = jj_consume_token(IDENT);
    NL();
         {if (true) return new HCISRGoToCallAST(locationIdentifier.image);}
    throw new Error("Missing return statement in function");
  }

  final public HCISRStatementAST Notecall() throws ParseException {
    jj_consume_token(NOTE);
    NL();
                {if (true) return new HCISRNoteCallAST();}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> functioncall returns function call ast - done?
  final public HCISRFunctionCallAST Functioncall() throws ParseException {
 ArrayList<String> methodSignature; String s; Token e;
         methodSignature = new ArrayList<String>();
    s = Anyfirst();
                   methodSignature.add(s);
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END:
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case otherwise:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case RETURNS:
      case RETURN:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_22;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END:
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case otherwise:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case RETURNS:
      case RETURN:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        s = Any();
                    methodSignature.add(s);
        break;
      case IDENT:
        e = jj_consume_token(IDENT);
                      methodSignature.add(e.image);
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    NL();
         {if (true) return new HCISRFunctionCallAST(methodSignature.toArray(new String[methodSignature.size()]));}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> returncall returns return clause ast - done?
  final public HCISRReturnsClauseAST Returncall() throws ParseException {
 Token returnVariable; String[] returnType;
    jj_consume_token(RETURN);
    returnVariable = jj_consume_token(IDENT);
    jj_consume_token(AS);
    returnType = TIDENT();
    NL();
         {if (true) return new HCISRReturnsClauseAST(returnVariable.image, returnType);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> catchcall returns catch clause ast - done?
  final public HCISRCatchClauseAST Catchcall() throws ParseException {
 String[] errorType; String errorVariable; ArrayList<HCISRStatementAST> commandList; HCISRReturnsClauseAST toRet; Object[] headreturn; HCISRStatementAST s;
         commandList = new ArrayList<HCISRStatementAST>();
    headreturn = Catchhead();
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OF:
      case A:
      case NAMED:
      case TYPE:
      case ARCHTYPE:
      case EXTERNALTYPE:
      case is_a_subtype_of:
      case and_has:
      case and_an_instance:
      case understands_the_following_commands:
      case which_initially_equals:
      case is_created_with_the_commands:
      case this_file_uses:
      case this_file_describes:
      case a_Class:
      case Functions:
      case a_Program:
      case define_a:
      case SET:
      case TO:
      case IF:
      case TRUE:
      case FALSE:
      case FOR_ALL:
      case DO:
      case WHILE:
      case COMPLAIN_ABOUT:
      case LABEL:
      case GOTO:
      case NOTE:
      case THEN:
      case IN:
      case AS:
      case WITH:
      case STRINGREF:
      case INTREF:
      case FLOATREF:
      case FUNCTIONREF:
      case BOOLREF:
      case make_a_new:
      case and_in_the_event_of_a:
      case the_following_functions_make_use_of:
      case IDENT:
      case NUMS:
      case LP:
      case RP:
      case CHARS:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_23;
      }
      s = Statement();
                                             commandList.add(s);
    }
    toRet = Returncall();
    jj_consume_token(END);
    NL();
                errorType = ((String[])(headreturn[0]));
                errorVariable = ((String)(headreturn[1]));
                {if (true) return new HCISRCatchClauseAST(errorType, errorVariable, commandList.toArray(new HCISRStatementAST[commandList.size()]), toRet);}
    throw new Error("Missing return statement in function");
  }

//codeblock -> statement -> catchcall -> catchhead returns {errortype[], errorvariable} - done?
  final public Object[] Catchhead() throws ParseException {
 String[] errorType; Token errorVariable; Object[] returnarray;
         returnarray = new Object[2];
    jj_consume_token(and_in_the_event_of_a);
    errorType = TIDENT();
    jj_consume_token(NAMED);
    errorVariable = jj_consume_token(IDENT);
    NL();
          returnarray[0] = errorType; returnarray[1] = errorVariable.image;
        {if (true) return returnarray;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_3R_24() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_scan_token(FLOATREF)) return true;
    if (jj_scan_token(NUMS)) return true;
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_scan_token(and_an_instance)) return true;
    if (jj_scan_token(IDENT)) return true;
    if (jj_scan_token(understands_the_following_commands)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(EOL)) return true;
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_scan_token(and_an_instance)) return true;
    if (jj_scan_token(IDENT)) return true;
    if (jj_scan_token(is_created_with_the_commands)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(IDENT)) return true;
    return false;
  }

  private boolean jj_3R_26() {
    if (jj_scan_token(INTREF)) return true;
    if (jj_scan_token(NUMS)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_26()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public HCISRTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[52];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfffffff0,0x4d3fffe0,0x0,0x0,0xc000000,0x0,0x0,0x20,0x0,0x0,0x20,0x380000,0x20000,0x0,0x1000,0x700,0x40,0x0,0x0,0x8000,0x0,0xfffffff0,0xfffffff0,0xefffffe0,0x0,0xfffffff0,0xfffffff0,0x0,0x4d3fffe0,0xfffffff0,0xfffffff0,0xefffffe0,0xefffffe0,0x0,0xefffffe0,0xfffffff0,0xfffffff0,0xfffffff0,0xfffffff0,0x0,0xa2c00000,0x0,0x8000,0x4d3fffe0,0x10000000,0xefffffe0,0xefffffe0,0xefffffe0,0xefffffe0,0xfffffff0,0xfffffff0,0xefffffe0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x7bffff,0x7b7fc0,0x440000,0x440000,0x0,0x100000,0x40000,0x0,0x40000,0x40000,0x0,0x0,0x0,0x440000,0x0,0x0,0x0,0x400,0x6000,0x0,0x40000,0x7fffff,0x7fffff,0x7fffff,0x8000,0x7fffff,0x7fffff,0x200,0x7b7fc0,0x7fffff,0x7fffff,0x7fffcf,0x7fffcf,0x10000,0x7fffcf,0x7fffff,0x7fffff,0x7fffff,0x7fffff,0x200,0xf,0x7c00,0x0,0x7fffc0,0x0,0x7fffcf,0x7fffcf,0x7fffcf,0x7fffcf,0x7fffff,0x7fffff,0x7fffcf,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[6];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public HCISR(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public HCISR(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new HCISRTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 52; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 52; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public HCISR(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new HCISRTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 52; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 52; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public HCISR(HCISRTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 52; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(HCISRTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 52; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[55];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 52; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 55; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 6; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
